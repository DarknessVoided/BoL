--[[
     ____        _      __       __                 ___   ___ 
    / __/_______(_)__  / /____  / /__  ___ ___ __  |_  | / _ \
   _\ \/ __/ __/ / _ \/ __/ _ \/ / _ \/ _ `/ // / / __/_/ // /
  /___/\__/_/ /_/ .__/\__/\___/_/\___/\_, /\_, / /____(_)___/ 
               /_/                   /___//___/               
               
    By Nebelwolfi

]]--

_G.ScriptologyVersion       = 2
_G.ScriptologyAutoUpdate    = true
_G.ScriptologyConfig        = MenuConfig("Scriptology", "Scriptology Loader")
_G.ScriptologyConfig:Section("MenuHeader", "Scriptology")

_G.ScriptologyLoadAwareness = false
_G.ScriptologyLoadEvade     = true

_G._Q, _G._W, _G._E, _G._R = 0, 1, 2, 3
-- { Scriptology Loader

  function Class(name)
    _G[name] = {}
    _G[name].__index = _G[name]
    local mt = {  __call = function(self, ...) local b = {} setmetatable(b, _G[name]) b:__init(b,...) return b end }
    setmetatable(_G[name], mt)
  end

  Callback.Bind("GameStart", function()
    _G.enemyHeroes              = {}
    _G.allyHeroes               = {}
    LoadEnemyHeroes()
    LoadAllyHeroes()
    if Update() then
      DelayAction(Load, 2)
    else
      PreLoad()
    end
  end)

  Callback.Bind("Tick", function()
    if loadedSPlugin then
      if loadedSPlugin.Tick then loadedSPlugin:Tick() end
      if loadedSPlugin.Killsteal then loadedSPlugin:Killsteal() end
      _G.Target = GetTarget(myHero.range+myHero.pos:DistanceTo(myHero.minBBox))
      if Config.kConfig.Combo:Value() and loadedSPlugin.Combo and ValidTarget(Target) then
        loadedSPlugin:Combo()
      end
      if Config.kConfig.Harrass:Value() and loadedSPlugin.Harrass and ValidTarget(Target) then
        loadedSPlugin:Harrass()
      end
      if Config.kConfig.LaneClear:Value() and loadedSPlugin.LaneClear then
        loadedSPlugin:LaneClear()
      end
      if (Config.kConfig.LastHit:Value() or Config.kConfig.LaneClear:Value()) and loadedSPlugin.LastHit then
        loadedSPlugin:LastHit()
      end
      DmgCalc()
    end
  end)

  Callback.Bind("Draw", function()
    if loadedSPlugin then
      if Config.Draws.Q:Value() and sReady[_Q] then
        Graphics.DrawCircle(myHero.x, myHero.y, myHero.z, data[0].range, Graphics.ARGB(0x7F, 0x00, 0xFF, 0x00))
      end
      if Config.Draws.W:Value() and sReady[_W] then
        Graphics.DrawCircle(myHero.x, myHero.y, myHero.z, data[1].range, Graphics.ARGB(0x7F, 0x00, 0xFF, 0x00))
      end
      if Config.Draws.E:Value() and sReady[_E] then
        Graphics.DrawCircle(myHero.x, myHero.y, myHero.z, data[2].range, Graphics.ARGB(0x7F, 0x00, 0xFF, 0x00))
      end
      if Config.Draws.R:Value() and sReady[_R] then
        Graphics.DrawCircle(myHero.x, myHero.y, myHero.z, data[3].range, Graphics.ARGB(0x7F, 0x00, 0xFF, 0x00))
      end
      if Config.Draws.DMG:Value() then
        local colors = {Graphics.ARGB(155,255,255,255), Graphics.ARGB(155,55,255,255), Graphics.ARGB(155,255,55,255), Graphics.ARGB(155,255,255,55)}
        local str = {[_Q] = "Q", [_W] = "W", [_E] = "E", [_R] = "R"}
        for i = 0,Game.HeroCount() do
          local hero = Game.Hero(i)
            if hero and ValidTarget(hero) then
              local barPos = Game.GetUnitHPBarOffset(hero);
              local barOffset = Game.GetUnitHPBarPos(hero);
              pos = {x = barPos.x - 67 + barOffset.x, y = barPos.y*50 + barOffset.y + 1}
              local totalDmg = 0
              for _, dmg in pairs(killTable[hero.networkID]) do
                local perc1 = (dmg) / hero.maxHealth
                local perc2 = (totalDmg) / hero.maxHealth
                totalDmg = totalDmg + dmg
                local offs = 1-(hero.maxHealth-hero.health) / hero.maxHealth
                if dmg > 0 then
                  Graphics.DrawLine(Geometry.Vector2(offs*105+pos.x-perc1*105-perc2*105,pos.y), Geometry.Vector2(offs*105+pos.x-perc2*105,pos.y), 8, colors[_])
                  Graphics.DrawText(str[_-1], 15, offs*105+pos.x-perc1*105-perc2*105, pos.y-20, colors[_])
                end
              end
           end
        end 
        for _, minion in pairs(Mobs.objects) do
          if minion and minion.team ~= myHero.team and not minion.dead and minion.visible and GetStacks(minion) > 0 and GetDistance(minion) <= 1000 then
            local damageE = GetDmg(_E, myHero, minion)
            local pos = Graphics.WorldToScreen(minion.pos)
            if damageE > minion.health then
              Graphics.DrawText("E Kill", 20, pos.x, pos.y, Graphics.ARGB(255,255,255,255))
            else
              Graphics.DrawText(math.floor(damageE/minion.health*100).."%", 20, pos.x, pos.y, Graphics.ARGB(255,255,255,255))
            end
          end
        end
      end
    end
  end)

  function GetClosestMinion(pos)
    local minionTarget = nil
    for i, minion in pairs(Mobs.objects) do
      if minion and minion.visible and not minion.dead and minion.bTargetable then
        if minionTarget == nil then 
          minionTarget = minion
        elseif GetDistanceSqr(minionTarget,pos) > GetDistanceSqr(minion,pos) then
          minionTarget = minion
        end
      end
    end
    return minionTarget
  end

  function DmgCalc()
    for i = 0,Game.HeroCount() do
      local enemy = Game.Hero(i)
      if enemy and enemy.team ~= myHero.team and not enemy.dead and enemy.visible then
        local damageQ = not sReady[_Q] and 0 or myHero.charName == "Kalista" and 0 or GetDmg(_Q, myHero, enemy) or 0
        local damageW = not sReady[_Q] and 0 or GetDmg(_W, myHero, enemy) or 0
        local damageE = not sReady[_Q] and 0 or GetDmg(_E, myHero, enemy) or 0
        local damageR = not sReady[_Q] and 0 or GetDmg(_R, myHero, enemy) or 0
        killTable[enemy.networkID] = {damageQ, damageW, damageE, damageR}
      end
    end
  end

  function GetTarget(range)
      local target, steps = nil, 10000
      for _, k in pairs(enemyHeroes) do
          local step = k.health / myHero:CalcDamage(k, 100)
          if k and k.valid and k.pos:DistanceTo(myHero.pos) < range and step < steps then
              target = k
              steps = step
          end
      end
      return target
  end

  function LoadEnemyHeroes()
    if myHero then
        for i = 0,Game.HeroCount() do
        local hero = Game.Hero(i)
        if hero.team ~= myHero.team then
          table.insert(enemyHeroes, hero)
        end
      end
    else
      DelayAction(LoadEnemyHeroes, 1)
    end
  end

  function LoadAllyHeroes()
    if myHero then
        for i = 0,Game.HeroCount() do
        local hero = Game.Hero(i)
        if hero.team == myHero.team and hero ~= myHero then
          table.insert(allyHeroes, hero)
        end
      end
    else
      DelayAction(LoadAllyHeroes, 1)
    end
  end

  function PreLoad()
    if myHero then
      Load()
      DmgCalc()
    else
      DelayAction(PreLoad, 1)
    end
  end

  local delayedActions, delayedActionsExecuter = {}, nil
  function DelayAction(func, delay, args) --delay in seconds
      if not delayedActionsExecuter then
          function delayedActionsExecuter()
              for t, funcs in pairs(delayedActions) do
                  if t <= os.clock() then
                      for _, f in ipairs(funcs) do if f.func then f.func(unpack(f.args or {})) end end
                      delayedActions[t] = nil
                  end
              end
          end;Callback.Bind("Tick", delayedActionsExecuter)
      end
      local t = os.clock() + (delay or 0)
      if delayedActions[t] then table.insert(delayedActions[t], { func = func, args = args })
      else delayedActions[t] = { { func = func, args = args } }
      end
  end

  function Set(list)
      local set = {}
      for _, l in ipairs(list) do 
        set[l] = true 
      end
      return set
  end

  function Load()
    if pcall(function() loadedSPlugin = _G[myHero.charName]() end) then
      Vars()
      ScriptologyMsg("Plugin: '"..myHero.charName.."' loaded")
      _G.ScriptologyLoaded = true
      AfterLoad()
    else
      ScriptologyMsg("Failed to load! (Champion not supported?)")
      ScriptologyConfig:Section("info", "Champion not supported")
    end
  end

  function Vars()
    stackTable = {}
    killTable = {}
    for i = 0,Game.HeroCount() do
      local enemy = Game.Hero(i)
      killTable[enemy.networkID] = {0, 0, 0, 0}
    end
    _G.Target = nil
    _G.sReady = {[_Q] = false, [_W] = false, [_E] = false, [_R] = false}
    Callback.Bind("Tick", function()for _=0,5 do;sReady[_]=(myHero:CanUseSpell(_)==0)end;end)
  end

  function ScriptologyMsg(msg) 
    Game.Chat.Print("<font color=\"#6699ff\"><b>[Scriptology Loader]: "..myHero.charName.." - </b></font> <font color=\"#FFFFFF\">"..msg..".</font>") 
  end

  function AfterLoad()
    if loadedSPlugin then
      ScriptologyConfig:Empty("empty", "<img style=' width:300px;height:auto;' src='http://i.imgur.com/rKrEPeu.gif'>")
      ScriptologyConfig:Menu(myHero.charName, myHero.charName)
    end
    if ScriptologyConfig[myHero.charName] then
      Mobs = MinionManager()
      local laneTable = {
        Set {"Kalista"}
      }
      _G.Config = ScriptologyConfig[myHero.charName]
      if laneTable[1][myHero.charName] then
        Config:Empty("empty", "<img style=' width:300px;height:auto;' src='http://i.imgur.com/82ZXel7.gif'>")
      end
      Config:Menu("Combo","Combo")
      Config.Combo:Section("MenuHeader", "Combo")
      Config:Menu("Harrass","Harrass")
      Config.Harrass:Section("MenuHeader", "Harrass")
      Config:Menu("LastHit","LastHit")
      Config.LastHit:Section("MenuHeader", "LastHit")
      Config:Menu("LaneClear","LaneClear")
      Config.LaneClear:Section("MenuHeader", "LaneClear")
      Config:Menu("Killsteal","Killsteal")
      Config.Killsteal:Section("MenuHeader", "Killsteal")
      Config:Menu("Misc","Misc")
      Config.Misc:Section("MenuHeader", "Misc")
      Config:Menu("Draws","Draws")
      Config.Draws:Section("MenuHeader", "Draws")
      Config.Draws:Boolean("Q", "Draw Q", true)
      Config.Draws:Boolean("W", "Draw W", true)
      Config.Draws:Boolean("E", "Draw E", true)
      Config.Draws:Boolean("R", "Draw R", true)
      Config.Draws:Boolean("DMG", "Draw DMG", true)
      Config:Menu("kConfig","Key Settings")
      Config.kConfig:Section("MenuHeader", "Key Settings")
    end
    if loadedSPlugin then
      if loadedSPlugin.Load then
        loadedSPlugin:Load()
      end

      if loadedSPlugin.ApplyBuff ~= nil then
        Callback.Bind("ApplyBuff", function(source, unit, buff)
          loadedSPlugin:ApplyBuff(source, unit, buff)
        end)
      end

      if loadedSPlugin.UpdateBuff ~= nil then
        Callback.Bind("UpdateBuff", function(unit, buff, stacks)
          loadedSPlugin:UpdateBuff(unit, buff, stacks)
        end)
      end

      if loadedSPlugin.RemoveBuff ~= nil then
        Callback.Bind("RemoveBuff", function(unit, buff)
          loadedSPlugin:RemoveBuff(unit, buff)
        end)
      end

      if loadedSPlugin.ProcessSpell ~= nil then
        Callback.Bind("ProcessSpell", function(unit, spell)
          loadedSPlugin:ProcessSpell(unit, spell)
        end)
      end

      if loadedSPlugin.Animation ~= nil then
        Callback.Bind("Animation", function(unit, ani)
          loadedSPlugin:Animation(unit, ani)
        end)
      end

      if loadedSPlugin.CreateObj ~= nil then
        Callback.Bind("CreateObj", function(obj)
          loadedSPlugin:CreateObj(obj)
        end)
      end

      if loadedSPlugin.DeleteObj ~= nil then
        Callback.Bind("DeleteObj", function(obj)
          loadedSPlugin:DeleteObj(obj)
        end)
      end

      if loadedSPlugin and loadedSPlugin.WndMsg then
        Callback.Bind("WndMsg", function(msg, key)
          loadedSPlugin:WndMsg(msg, key)
        end)
      end

      if loadedSPlugin and loadedSPlugin.Msg then
        Callback.Bind("WndMsg", function(msg, key)
          loadedSPlugin:Msg(msg, key)
        end)
      end
    end
  end

  function GetStacks(x)
    return stackTable[x.networkID] or 0
  end

  function Update()
    return false
  end

  function GetDmg(spell, source, target)
    if target == nil or source == nil then
      return
    end
    local ADDmg            = 0
    local APDmg            = 0
    local TRUEDmg          = 0
    local AP               = source.ap
    local Level            = source.level
    local TotalDmg         = source.totalDamage
    local crit             = myHero.critChance
    local crdm             = myHero.critDmg

    if source ~= myHero then
      return TotalDmg*(1-ArmorPercent)
    end
    if spell == "IGNITE" then
      return 50+20*Level/2
    elseif spell == "AD" then
      ADDmg = TotalDmg
      if source.charName == "Ashe" then
        ADDmg = TotalDmg*1.1+(1+crit)*(1+crdm)
      elseif source.charName == "Kalista" then
        ADDmg = ADDmg * 0.9
      elseif source.charName == "Teemo" then
        APDmg = APDmg + 9 * level + 0.3 * AP
      elseif source.charName == "Orianna" then
        APDmg = APDmg + 2 + 8 * math.ceil(Level/3) + 0.15*AP
      else
        ADDmg = ADDmg * (1 + crit)
      end
    elseif type(spell) == "number" then
      if data[spell].dmgAD then ADDmg = data[spell].dmgAD(AP, source:GetSpellData(spell).level, Level, TotalDmg, source, target) end
      if data[spell].dmgAP then APDmg = data[spell].dmgAP(AP, source:GetSpellData(spell).level, Level, TotalDmg, source, target) end
      if data[spell].dmgTRUE then TRUEDmg = data[spell].dmgTRUE(AP, source:GetSpellData(spell).level, Level, TotalDmg, source, target) end
    end
    dmg = source:CalcDamage(target, ADDmg)+source:CalcMagicDamage(target, APDmg)+TRUEDmg
    --dmgMod = (UnitHaveBuff(source, "summonerexhaust") and 0.6 or 1) * (UnitHaveBuff(target, "meditate") and 1-(target:GetSpellData(_W).level * 0.05 + 0.5) or 1)
    return math.floor(dmg) --* dmgMod
  end

  function kalE(x) if x <= 1 then return 10 else return kalE(x-1) + 2 + x end end

  function UnitHaveBuff(unit, buffName)
    if unit and buffName and unit.buffCount then
      for _=1, 64 do
        local buff = unit:GetBuff(_)
        --if buff and buff.valid and buff.startT <= GetGameTimer() and buff.endT >= GetGameTimer() and buff.name ~= nil and (buff.name:find(buffName) or buffName:find(buff.name) or buffName:lower() == buff.name:lower()) then 
        --  return true
        --end
      end
    end
    return false
  end

  function ValidTarget(unit, range)
    if unit and unit.valid and unit.visible and not unit.dead and unit.team ~= myHero.team then
      return (not range or myHero.pos:DistanceTo(unit.pos) < range)
    end
    return false
  end

  function GetDistance(unit1, unit2)
    unit1 = unit1.pos
    unit2 = unit2 and unit2.pos or myHero.pos
    return unit1:DistanceTo(unit2)
  end

  function Cast(Spell, target, hitchance, source) -- maybe the packetcast gets some functionality somewhen?
    local pred = (hitchance and type(hitchance) == "number")
    if not target and not pred then
      myHero:CastSpell(Spell)
      return true
    elseif target and target.networkID and not pred then
      myHero:CastSpell(Spell, target)
      return true
    elseif target and target.pos then
      xPos = target.x
      zPos = target.z
      myHero:CastSpell(Spell, xPos, zPos)
      return true
    end
    return false
  end


-- { MinionManager

  Class "MinionManager"

  function MinionManager:__init()
    self.objects = {}
    for k=1,Game.ObjectCount(),1 do
      local object = Game.Object(k)
      if object and object.valid and object.team ~= myHero.team and object.name and (object.name == "Barrel" or (object.type == "obj_AI_Minion" and (object.name:find('Minion_T') or object.name:find('Blue') or object.name:find('Red') or object.team == 300 or object.name:find('Bilge') or object.name:find('BW')))) then
        self.objects[#self.objects+1] = object
      end
    end
    Callback.Bind("CreateObj", function(o) self:CreateObj(o) end)
    return self
  end

  function MinionManager:CreateObj(object)
    if object and object.valid and object.team ~= myHero.team and object.name and (object.name == "Barrel" or (object.type == "obj_AI_Minion" and (object.name:find('Minion_T') or object.name:find('Blue') or object.name:find('Red') or object.team == 300 or object.name:find('Bilge') or object.name:find('BW')))) then
      self.objects[self:FindDeadPlace() or #self.objects+1] = object
    end
  end

  function MinionManager:FindDeadPlace()
    for i=1, #self.objects do
      local object = self.objects[i]
      if not object or not object.valid or object.dead then
        return i
      end
    end
  end

-- }

Class "Hecarim"
  function Hecarim:__init()
    data = {
      [_Q] = { speed = 1200, delay = 0.5, range = 1150, width = 40, collision = true, aoe = false, type = "linear", dmgAD = function(AP, level, Level, TotalDmg, source, target) return 1000 end},
      [_W] = { delay = 1.5, range = 5000},
      [_E] = { range = 1000, dmgAD = function(AP, level, Level, TotalDmg, source, target) return 1000 end},
      [_R] = { range = 2000}
    }
  end

  function Hecarim:Load()
    Config.kConfig:KeyBinding("Combo", "Combo", " ", false, false)
    Config.kConfig:KeyBinding("Harrass", "Harrass", "C", false, false)
    Config.kConfig:KeyBinding("LastHit", "Last hit", "X", false, false)
    Config.kConfig:KeyBinding("LaneClear", "Lane Clear", "V", false, false)
  end

Class "Kalista"

  function Kalista:__init()
    data = {
      [_Q] = { speed = 1200, delay = 0.5, range = 1150, width = 40, collision = true, aoe = false, type = "linear", dmgAD = function(AP, level, Level, TotalDmg, source, target) return 0-50+60*level+TotalDmg end},
      [_W] = { delay = 1.5, range = 5000},
      [_E] = { range = 1000, dmgAD = function(AP, level, Level, TotalDmg, source, target) return GetStacks(target) > 0 and (10 + (10 * level) + (TotalDmg * 0.6)) + (GetStacks(target)-1) * (kalE(level) + (0.175 + 0.025 * level)*TotalDmg) or 0 end},
      [_R] = { range = 2000}
    }
    stackTable = {}
    self.Target = nil
    self.soulMate = nil
    self.saveAlly = false
    --self:FindMate()
  end

  function Kalista:Load()
    self:Menu()
  end

  function Kalista:FindMate()
    if myHero then
      for k,v in pairs(allyHeroes) do
        for _=0, v.buffCount do
          local buff = v:GetBuff(_)
          if buff and buff.valid and buff.name == "kalistacoopstrikeally" then
          self.soulMate = v
          Config.Misc:Boolean("R", "Save ally with R ("..self.soulMate.charName..")", true)
          end
        end
      end
    else
      DelayAction(FindMate, 1)
    end
  end

  function Kalista:Menu()
    Config.Combo:Boolean("Q", "Use Q", true)
    Config.Combo:Boolean("E", "Use E", true)
    Config.Harrass:Boolean("Q", "Use Q", true)
    Config.Harrass:Boolean("E", "Use E", true)
    Config.LaneClear:Boolean("Q", "Use Q", true)
    Config.LaneClear:Boolean("E", "Use E", true)
    Config.LastHit:Boolean("Q", "Use Q", true)
    Config.LastHit:Boolean("E", "Use E", true)
    Config.Killsteal:Boolean("Q", "Use Q", true)
    Config.Killsteal:Boolean("E", "Use E", true)
    Config.Harrass:DropDown("manaQ", "Mana Q", 5, {10, 20, 30, 40, 50, 60, 70, 80, 90, 100})
    Config.Harrass:DropDown("manaE", "Mana E", 3, {10, 20, 30, 40, 50, 60, 70, 80, 90, 100})
    Config.LaneClear:DropDown("manaQ", "Mana Q", 5, {10, 20, 30, 40, 50, 60, 70, 80, 90, 100})
    Config.LaneClear:DropDown("manaE", "Mana E", 3, {10, 20, 30, 40, 50, 60, 70, 80, 90, 100})
    Config.LaneClear:DropDown("Ea", "Execute X Minions", 2, {1, 2, 3, 4, 5})
    Config.LastHit:DropDown("manaQ", "Mana Q", 5, {10, 20, 30, 40, 50, 60, 70, 80, 90, 100})
    Config.LastHit:DropDown("manaE", "Mana E", 3, {10, 20, 30, 40, 50, 60, 70, 80, 90, 100})
    Config.LastHit:DropDown("Ea", "Execute X Minions", 2, {1, 2, 3, 4, 5})
    Config.kConfig:KeyBinding("Combo", "Combo", " ", false, false)
    Config.kConfig:KeyBinding("Harrass", "Harrass", "C", false, false)
    Config.kConfig:KeyBinding("LastHit", "Last hit", "X", false, false)
    Config.kConfig:KeyBinding("LaneClear", "Lane Clear", "V", false, false)
    Config.Misc:Boolean("Ej", "Use E to steal Jungle", true)
    Config.Misc:Boolean("Ea", "Use E always if it", true)
    Config.Misc:DropDown("Eaa", "executes X Minions", 4, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
    Config.Misc:Boolean("Ed", "Use E if you are about to die", true)
    Config.Misc:Boolean("AAGap", "AAs as Gapcloser on minions", true)
    Config.Misc:Boolean("R", "Save ally with R (none bound)", true)
    Config.Misc:DropDown("Rhp", "Save ally under X% hp", 2, {10, 20, 30, 40, 50, 60, 70, 80, 90, 100})
  end

  function Kalista:ProcessSpell(unit, spell)
    if not unit or not spell then return end
    if spell.name == "KalistaPSpellCast" and spell.target.pos:DistanceTo(myHero.pos) < 1000 then 
      self.soulMate = spell.target
      Config.Misc:Boolean("R", "Save ally with R ("..self.soulMate.charName..")", true)
      ScriptologyMsg("Soulmate found: "..spell.target.charName)
    end
    if spell.name:lower():find("attack") and GetStacks(spell.target) > 0 and spell.target and unit == myHero then
      stackTable[spell.target.networkID] = GetStacks(spell.target) + 1
      Game.Chat.Print(""..GetStacks(spell.target))
    end
    if Config.Misc.Ed:Value() and unit.team ~= myHero.team and myHero.health/myHero.maxHealth < 0.125 and (myHero == spell.target or myHero.pos:DistanceTo(spell.endPos) < myHero.boundingRadius*3) then
      Cast(_E)    
    end
    if not self.soulMate or unit.type ~= myHero.type then return end
    if Config.Misc.R:Value() and self.saveAlly and myHero.pos:DistanceTo(self.soulMate.pos) < data[3].range and unit.team ~= self.soulMate.team and (self.soulMate == spell.target or self.soulMate.pos:DistanceTo(spell.endPos) < self.soulMate.boundingRadius*3) then
      Cast(_R)
      ScriptologyMsg("Saving soulmate from spell: "..spell.name)
      self.saveAlly = false
    end
  end

  function Kalista:Killsteal()
    for k,enemy in pairs(enemyHeroes) do
      if enemy and enemy.valid and not enemy.dead then
        local health = enemy.health
        if sReady[_E] and GetStacks(enemy) > 0 and health < GetDmg(_E, myHero, enemy) and Config.Killsteal.E:Value() and enemy.pos:DistanceTo(myHero.pos) < data[2].range then
          Cast(_E)
        elseif sReady[_Q] and health < GetDmg(_Q, myHero, enemy) and Config.Killsteal.Q:Value() and enemy.pos:DistanceTo(myHero.pos) < data[0].range then
          Cast(_Q, enemy, 2)
        end
      end
    end
  end

  function Kalista:Tick()
    if sReady[_E] and ((Config.kConfig.LastHit:Value() and Config.LastHit.E:Value()) or (Config.kConfig.LaneClear:Value() and Config.LaneClear.E:Value()) or Config.Misc.Ej:Value() or Config.Misc.Ea:Value()) then
      local killableCounter = 0
      local killableCounterJ = 0 
      for minion,winion in pairs(Mobs.objects) do
        local EMinionDmg = GetDmg(_E, myHero, winion)  
        if winion ~= nil and winion.health > 0 and EMinionDmg-5 > winion.health and myHero.pos:DistanceTo(winion.pos) < data[2].range then    
          killableCounter = killableCounter + 1
        end
      end
      for minion,winion in pairs(Mobs.objects) do
        local EMinionDmg = GetDmg(_E, myHero, winion)  
        if winion ~= nil and winion.health > 0 and EMinionDmg-15 > winion.health and myHero.pos:DistanceTo(winion.pos) < data[2].range then
          if (string.find(winion.charName, "Crab") or string.find(winion.charName, "Rift") or string.find(winion.charName, "Baron") or string.find(winion.charName, "Dragon") or string.find(winion.charName, "Gromp") or ((string.find(winion.charName, "Krug") or string.find(winion.charName, "Murkwolf") or string.find(winion.charName, "Razorbeak") or string.find(winion.charName, "Red") or string.find(winion.charName, "Blue")))) then
            if not string.find(winion.charName, "Mini") then       
              killableCounterJ = killableCounterJ + 1
            end
          end
        end
      end
      if (Config.kConfig.LaneClear:Value() and killableCounter >= Config.LaneClear.Ea:Value()) or (Config.kConfig.LastHit:Value() and killableCounter >= Config.LastHit.Ea:Value()) or (Config.Misc.Ej:Value() and killableCounterJ >= 1) or (Config.Misc.Ea:Value() and killableCounter+killableCounterJ >= Config.Misc.Eaa:Value()) then
        Cast(_E)
      end
    end
    if self.soulMate and self.soulMate.health/self.soulMate.maxHealth < Config.Misc.Rhp/100 then
      self.saveAlly = true
    else
      self.saveAlly = false
    end
    if Target and Config.kConfig.Combo:Value() and Config.Misc.AAGap:Value() and myHero.pos:DistanceTo(Target.pos) > myHero.range+myHero.pos:DistanceTo(myHero.minBBox) then
      local winion = ClosestMinion(myHero.pos)  
      if winion ~= nil then
        myHero:Attack(winion)
        myHero:Move(mousePos.x, mousePos.z)
      end    
    end
  end

  function Kalista:LastHit()
    if sReady[_Q] and ((Config.kConfig.LastHit:Value() and Config.LastHit.Q:Value() and Config.LastHit.manaQ:Value()*10 <= 100*myHero.mana/myHero.maxMana) or (Config.kConfig.LaneClear:Value() and Config.LaneClear.Q:Value() and Config.LaneClear.manaQ:Value()*10 <= 100*myHero.mana/myHero.maxMana)) then
      for minion,winion in pairs(Mobs.objects) do
        local MinionDmg = GetDmg(_Q, myHero, winion)
        if winion and MinionDmg and MinionDmg >= winion.health+winion.shield and not winion.dead and myHero.pos:DistanceTo(winion.pos) < data[0].range then
          Cast(_Q, winion, 1.2)
        end
      end
    end
  end

  function Kalista:Combo()
    if sReady[_Q] and Config.Combo.Q:Value() and ValidTarget(self.Target, data[0].range) and myHero.mana >= 75+myHero:GetSpellData(_Q).level*5 then
      Cast(_Q, self.Target, 2)
    end
    if sReady[_E] and Config.Combo.E:Value() and ValidTarget(self.Target, data[2].range) then
      if GetDmg(_E, myHero, self.Target) >= self.Target.health then
        Cast(_E)
      end
      local killableCounter = 0
      for minion,winion in pairs(Mobs.objects) do
        local EMinionDmg = GetDmg(_E, myHero, winion)      
        if winion ~= nil and winion.health > 0 and EMinionDmg and EMinionDmg >= winion.health+winion.shield and ValidTarget(winion, data[2].range) and myHero.pos:DistanceTo(winion.pos) < data[2].range then
          killableCounter = killableCounter +1
        end   
      end   
      if killableCounter > 0 and GetStacks(self.Target) > 0 and self.Target.health > 0 then
        Cast(_E)
      end
    end
  end
  
  function Kalista:Harrass()
    if sReady[_Q] and Config.Harrass.Q:Value() and Config.Harrass.manaQ:Value()*10 <= 100*myHero.mana/myHero.maxMana and myHero.mana >= 75+myHero:GetSpellData(_Q).level*5 then
      Cast(_Q, self.Target, 2)
    end
    if sReady[_E] and Config.Harrass.E:Value() and ValidTarget(self.Target, data[2].range) then
      local harrassUnit = nil
      local killableCounter = 0
      for minion,winion in pairs(Mobs.objects) do
        local EMinionDmg = GetDmg(_E, myHero, winion)      
        if winion ~= nil and EMinionDmg and EMinionDmg >= winion.health+winion.shield and ValidTarget(winion, data[2].range) and myHero.pos:DistanceTo(winion.pos) < data[2].range then
          killableCounter = killableCounter +1
        end   
      end 
      for i, unit in pairs(enemyHeroes) do    
        local EChampDmg = GetDmg(_E, myHero, unit)      
        if unit ~= nil and EChampDmg and EChampDmg > 0 and ValidTarget(unit, data[2].range) and GetDistance(unit) < data[2].range then
          harrassUnit = unit
        end      
      end    
      if killableCounter >= 1 and harrassUnit ~= nil then
        Cast(_E)
      end
    end
  end

  function Kalista:ApplyBuff(source, unit, buff)
    if unit and source and source == myHero and buff and buff.name == "kalistaexpungemarker" then
      stackTable[unit.networkID] = 1
    end
  end

  function Kalista:UpdateBuff(unit, buff, stacks)
    if unit and buff and stacks and buff.name == "kalistaexpungemarker" then
      stackTable[unit.networkID] = stacks
    end
  end

  function Kalista:RemoveBuff(unit, buff)
    if unit and buff and buff.name == "kalistaexpungemarker" then
      stackTable[unit.networkID] = 0
    end
  end